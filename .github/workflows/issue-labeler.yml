name: Issue Auto-Labeler

on:
  issues:
    types: [opened, edited]

jobs:
  label:
    runs-on: ubuntu-latest
    permissions:
      issues: write

    steps:
      - name: Apply labels based on issue form inputs
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.issue.body || '';
            const labels = [];

            // --- Helper: extract the chosen value for a given form label ---
            // GitHub renders form inputs as "### <label>\n\n<value>\n"
            // We use a more robust regex to handle various platform rendering quirks.
            function getFormValue(label) {
              const safeLabel = label.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const regex = new RegExp(`### ${safeLabel}\\s*\\n\\n([\\s\\S]*?)(?:\\n{2,}|\\n###|$)`);
              const match = body.match(regex);
              const value = match ? match[1].trim() : null;
              
              // Ignore placeholders and "Other"
              return (value === '_No response_' || value === 'Other' || value === 'None') ? null : value;
            }

            // --- Service / Component ---
            const serviceMap = {
              'Authingway':          'authingway',
              'Clearingway':         'clearingway',
              'Findingway':          'findingway',
              'Moddingway':          'moddingway',
              'Naurffxiv':           'naurffxiv',
              'AppHost (Aspire)':    'aspire',
              'Shared Libraries':    'shared-libraries',
              'Global / Monorepo':   'global',
            };

            const service = getFormValue('Service / Component');
            if (service && serviceMap[service]) {
              labels.push(serviceMap[service]);
            }

            // --- Functional Area ---
            const areaMap = {
              'Backend / API':                'Backend',
              'Frontend / UI':                'Frontend',
              'Infrastructure (CI/CD, Docker)': 'Infrastructure',
              'Security':                     'security',
              'Documentation':                'Documentation',
              'Quality / Testing':            'testing',
              'Developer Experience':         'devex',
            };

            const area = getFormValue('Functional Area');
            if (area && areaMap[area]) {
              labels.push(areaMap[area]);
            }

            // --- Priority (user-story.yml) ---
            const priorityMap = {
              'Low':      'low',
              'Medium':   'medium',
              'High':     'high',
              'Critical': 'critical',
            };

            const priority = getFormValue('Priority');
            if (priority && priorityMap[priority]) {
              labels.push(priorityMap[priority]);
            }

            // --- Impact (tech-debt.yml) ---
            const impactMap = {
              'Low':    'low',
              'Medium': 'medium',
              'High':   'high',
            };

            const impact = getFormValue('Impact');
            if (impact && impactMap[impact]) {
              labels.push(impactMap[impact]);
            }

            // --- Apply labels (skip if none found) ---
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner:   context.repo.owner,
                repo:    context.repo.repo,
                issue_number: context.payload.issue.number,
                labels:  labels,
              });

              console.log('Applied labels:', labels);
            } else {
              console.log('No labels matched.');
            }
